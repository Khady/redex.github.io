{
  "name": "bs-json",
  "version": "0.2.4",
  "description": "Experimental JSON encode/decode library for BuckleScript.",
  "updated": "2017-11-02T20:18:48.620Z",
  "keywords": [
    "bucklescript",
    "json"
  ],
  "license": "MIT",
  "readme": "# bs-json\n\nExperimental JSON encode/decode library for BuckleScript.\n\nThe Decode module in particular provides a basic set of decoder functions to be composed into more complex decoders. A decoder is a function that takes a `Js.Json.t` and either returns a value of the desired type if successful or raises a `DecodeError` exception if not. Other functions accept a decoder and produce another decoder. Like `array`, which when given a decoder for type `t` will return a decoder that tries to produce a value of type `t array`. So to decode an `int array` you combine `Json.Decode.int` with `Json.Decode.array` into `Json.Decode.(array int)`. An array of arrays of ints? `Json.Deocde.(array (array int))`. Dict containing arrays of ints? `Json.Decode.(dict (array int))`.\n\n## Example\n\n```ml\n(* OCaml *)\ntype line = {\n  start: point;\n  end_: point;\n  thickness: int option\n}\nand point = {\n  x: float;\n  y: float\n}\n\nmodule Decode = struct\n  let point json =\n    let open! Json.Decode in {\n      x = json |> field \"x\" float;\n      y = json |> field \"y\" float\n    }\n\n  let line json =\n    Json.Decode.{\n      start     = json |> field \"start\" point;\n      end_      = json |> field \"end\" point;\n      thickness = json |> optional (field \"thickness\" int)\n    }\nend\n\nlet data = {| {\n  \"start\": { \"x\": 1.1, \"y\": -0.4 },\n  \"end\":   { \"x\": 5.3, \"y\": 3.8 }\n} |}\n\nlet line = data |> Js.Json.parseExn\n                |> Decode.line\n```\n\n```reason\n/* Reason */\ntype line = {\n  start: point,\n  end_: point,\n  thickness: option(int)\n}\nand point = {\n  x: float,\n  y: float\n};\n\nmodule Decode = {\n  let point = (json) =>\n    Json.Decode.{\n      x: json |> field(\"x\", float),\n      y: json |> field(\"y\", float)\n    };\n\n  let line = (json) =>\n    Json.Decode.{\n      start:     json |> field(\"start\", point),\n      end_:      json |> field(\"end\", point),\n      thickness: json |> optional(field(\"thickness\", int))\n    };\n};\n\nlet data = {| {\n  \"start\": { \"x\": 1.1, \"y\": -0.4 },\n  \"end\":   { \"x\": 5.3, \"y\": 3.8 }\n} |};\n\nlet line = data |> Js.Json.parseExn\n                |> Decode.line;\n```\n\nSee [examples](https://github.com/reasonml-community/bs-json/blob/master/examples/) for more.\n\n## Installation\n\n```sh\nnpm install --save bs-json\n```\n\nThen add `bs-json` to `bs-dependencies` in your `bsconfig.json`:\n```js\n{\n  ...\n  \"bs-dependencies\": [\"bs-json\"]\n}\n```\n\n## Changes\n\n### 0.2.4\n* Added `Json.Encode.bool`\n* Added `Json.Encode.pair`\n' Added `Json.Encode.withDefault`\n* Added `Json.Encode.nullable`\n* Added `Json.Encode.arrayOf`\n* Added `Json.Encode.jsonArray` as replacement for `Json.Encode.array`\n* Deprecated `Json.Encode.array`\n\n### 0.2.3\n* Fixed embarrassing bug where an API was used that isn't available on IE (honestly more embarrassed on behalf IE though)\n\n### 0.2.2\n* Added `Json.Decode.pair`\n\n### 0.2.1\n* Added `Json.Encode.list`\n\n### 0.2.0\n* Breaking: Renamed `Json.Encode.object_` to `Json.Encode.dict`\n* Added `Json.Encode.object_` taking a list of properties instead of a Json.Dict.t as before"
}